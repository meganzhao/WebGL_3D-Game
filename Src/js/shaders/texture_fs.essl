Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	varying vec2 texCoord;
	uniform sampler2D colorTexture; 
	uniform vec4 lightPos[1]; // xyz is the direction, w is 0
	uniform vec4 lightPowerDensity[1]; // w ignored
	uniform vec4 mainDir[1];
	uniform vec3 cameraPosition;

	varying vec4 worldPos;
	varying vec3 worldNormal;

	void main(void) {

		gl_FragColor = vec4(0,0,0,0);

		for (int i = 0; i < 1; i++){
			vec3 lightDir = lightPos[0].xyz - worldPos.xyz * lightPos[0].w;
			vec3 viewDir = cameraPosition - worldPos.xyz;

			vec4 powerDensity;
			if (mainDir[i].w == 1.0){
				powerDensity = lightPowerDensity[i] * pow(max(0.0,dot(normalize(mainDir[i].xyz),normalize((-1.0) * lightDir))), 0.2);
			} else{
				powerDensity = lightPowerDensity[i];
			}

			float cosTheta = dot(normalize(lightDir), normalize(worldNormal));
			vec4 diffuseLight = powerDensity / pow(length(lightDir), 2.0) * vec4(
				texture2D(colorTexture, texCoord).rgb * cosTheta,1);

			float shininess = 0.6;
			vec3 halfwayVector = normalize(viewDir + lightDir) * (-1.0);
			float brightness = pow(max(0.0, dot(normalize(worldNormal),halfwayVector)),shininess);
			vec4 specularLight = powerDensity / pow(length(lightDir), 2.0) * vec4(
				texture2D(colorTexture, texCoord).rgb * brightness,1);

			//vec3 lightToSurfaceDistance = lightPos[1].xyz - worldPos.xyz * lightPos[1].w;
			//float spotCos = dot(spotLightDirection, lightToSurfaceDistance);
			//float spotPowerDensity = pow(spotCos, 0.1);
			//vec4 spotLight = vec4(texture2D(colorTexture, texCoord).rgb * spotPowerDensity,1);

			gl_FragColor += diffuseLight + specularLight;
		}


		//add for loop to add up all the light together
		//mmm = normalize(lightPos.xyz - worldPos.xyz * lightPos.w)
		//for directional
		//vec3 M = powerDensity.rgb
		//for point
		//distance between lightPs and worldPos and square; powerDensity.rgb / dot(x,x)
		//x,x is the mmm without normalize
	}
`;