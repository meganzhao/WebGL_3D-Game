Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	varying vec2 texCoord;
	uniform sampler2D colorTexture; 
	uniform vec4 lightPos[2]; // xyz is the direction, w is 0
	uniform vec4 powerDensity[1]; // w ignored
	uniform vec3 spotLightDirection;

	varying vec4 worldPos;
	varying vec3 worldNormal;

	void main(void) {
		
		float cosTheta = dot(normalize(lightPos[0].xyz), normalize(worldNormal));
		vec3 distance = lightPos[0].xyz - worldPos.xyz * lightPos[0].w;
		vec4 diffuseLight = vec4(powerDensity[0].rgb / dot(distance, distance) * 
			texture2D(colorTexture, texCoord).rgb * cosTheta,1);

		vec3 cameraPosition = vec3(1,1,1);	
		vec3 directionToCamera = normalize(cameraPosition - worldPos.xyz);
		vec3 halfwayVector = normalize(directionToCamera + lightPos[0].xyz);

		float specularShininess = 0.1;
		float specularBrightness = (pow(max(0.0, dot(worldNormal,halfwayVector)),specularShininess));
		vec4 specularLight = vec4(texture2D(colorTexture, texCoord).rgb * specularBrightness,1);

		vec3 lightToSurfaceDistance = lightPos[1].xyz - worldPos.xyz * lightPos[1].w;
		float spotCos = dot(spotLightDirection, lightToSurfaceDistance);
		float spotPowerDensity = pow(spotCos, 0.1);
		vec4 spotLight = vec4(texture2D(colorTexture, texCoord).rgb * spotPowerDensity,1);

		gl_FragColor = diffuseLight + specularLight + spotLight;


		//add for loop to add up all the light together
		//mmm = normalize(lightPos.xyz - worldPos.xyz * lightPos.w)
		//for directional
		//vec3 M = powerDensity.rgb
		//for point
		//distance between lightPs and worldPos and square; powerDensity.rgb / dot(x,x)
		//x,x is the mmm without normalize
	}
`;